# 复杂嵌入式系统软件的演进式设计

---

[TOC]

---

## 引言

复杂嵌入式系统软件，特指具有如下主要特点的嵌入式软件：

- 软件规模大，百万、千万级以上代码量；
- 特性复杂，业务流程内在交织、互相影响，普遍具有事务性要求；
- 结构复杂，由驱动、OS、中间件、协议、控制等特点各异的软件部件组成，需要管理各种专有硬件和逻辑资源；
- 软件生命周期长，常常数年或数十年以上，需要在长生命周期中持续兼容各种变化；
- 对性能、可靠性、安全性等要求高；

由于上述特点，复杂嵌入式系统软件的设计和交付往往跨越多个团队，需要多维度的设计能力支撑，在整个长生命周期中需要持续地进行设计演进。

本文就作者与不同类型嵌入式系统软件团队的合作经验，结合作者之前的培训和大会分享的部分内容，整理了复杂嵌入式系统软件所涉及的主要设计方法，着重讨论了不同设计方法的特点以及如何有效协同以支撑起复杂嵌入式系统软件的长期设计演进。

## 分层分模块设计

对于复杂软件系统，软件工程领域总结的第一个有效的设计方法，是通过“分层分模块”的设计方式对问题进行分而治之。这一方法从上世纪70年代开始就已作为软件工程的经典方法。

如下图，一个系统软件，依据对其软件构成的职责分工、功能复用和性能约束等维度的分析，将软件拆解划分到不同的逻辑层次和模块，制定好之间的接口和依赖关系，让各个模块可以相对独立地完成进一步的内部设计和开发，最后进行集成测试和交付。

<div align="center"><img src="images/layer_module.png" width="60%"></div>

不难看出“分层分模块”方法通过分离和降解复杂度的方式，降低了软件系统整体的设计和开发的难度。除此之外更重要的是：它使得大规模软件可以由多个团队进行协作和并行设计开发，而且这一过程可以被工程化的管理起来。

因此，复杂嵌入式系统软件的整体设计往往优先采用“分层分模块”方法。这种方式下软件交付团队容易和模块责任田进行对应，团队的职责、进度、质量和效率容易被度量和管理。

复杂嵌入式系统软件的层次和模块的划分设计原则，在大的维度上遵循的是行业标准和产品形态约束、在中级维度上遵循性能隔离原则(例如管控面和数据面分离)，在进一步的维度上依据硬件部署特点（例如模块划分按照部署在中心单板或边缘单板、以及部署在单板上的中心或非中心处理器上）。

很多嵌入式系统软件把上述分层和分模块的设计定义为架构设计。

显而易见，这种顶层的架构设计需要有行业和产品经验以及多元的业务和软硬件背景知识，大部分软件工程师涉及到的机会并不多。同时这种设计的变化相对较慢，大多数时候画一张结构整齐的“楼房图”就可以用好几年。

不过，这些年随着硬件的迭代速率提升、产品形态的多元化，以及新的软件技术和基础设施的涌现，导致对软件架构提出大量新的挑战，例如软件在设计上做到可灵活部署和可裁剪就成为是一个常见的诉求。

而分层分模块架构在应对这些新挑战的时候有些捉襟见肘。

例如分层架构对模块之间的接口依赖只约束了层与层之间的单向向下依赖，而同一层内部的模块之间则可以互相依赖（否则就要划分更多的层）。这样同一层内的模块由于存在双向依赖，则被迫遵守共同复用和共同发布的原则，因此对模块的独立裁剪就难以做到。

另外在嵌入式系统的分层分模块设计中，为了追求极致性能，层次和模块的划分容易和某种部署架构紧密耦合。我们见过不少嵌入式系统软件中的逻辑架构设计，其实直接就是部署架构，这种架构的软件在支持多种部署方式时往往需要伤筋动骨。

说到这里可能会引出分层分模块设计是否已经过时了的结论？

这里做下澄清：分层分模块设计依旧是复杂软件的基底层设计方法，即使是云化软件普遍采用微服务架构也需要对服务进行层次关系设计。Adam Drake 也在文章[《Enough with the microservices》](https://link.jianshu.com/?t=https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html)中指出微服务架构应该先从良好的模块化设计做起。

可见即使是采用组件化或服务化架构，其背后的基底层设计能力也依然是分层的模块化设计能力。**组件化和服务化从本质上讲是一种架构风格，并不是一种通用设计方法**。组件化是为了让软件模块能够在某一平台上标准化的发布和复用，而采用的一系列的架构、技术框架和实现标准，而服务化则把这种能力推到了分布式环境。因此期望使用了组件化和服务化架构就能解决前述的各种问题是不现实的。

这里的关键是我们面临的场景和问题变得更复杂了，复杂嵌入式系统经常是对上的业务场景、对下的硬件结构、以及对内的技术架构都在同时变化。

对这种同时面临多维度变化且变化范围相互交织的软件，如果只依赖“层次化的模块分解式”的设计实现方法，会导致软件中要么存在大量的重复（表达为通过“目录/文件/代码实现”的拷贝性显式重复，或者通过拉分支的隐式重复），要么存在大量的霰弹式修改（表达为大面积分布的相似结构的复杂“if-else”，经常修改一个功能需要霰弹式的修改几十上百处，不仅容易遗漏，而且修改波及范围大测试成本高）。

分层分模块架构适合在系统的稳定边界范围内做宏观设计，但是在多维变化且变化范围相互交织的场景下是捉襟见肘的（组件化或服务化架构也是类似），我们需要寻求其它更高阶的设计方法和架构模式来解决问题。

## 4+1视图的价值

4+1视图最早由 Philippe Kruchten 在1995年的《IEEE Software》上发表的题为《The 4+1 View Model of Architecture》的论文中提出。

<div align="center"><img src="images/4_1_view.png" width="60%"></div>
</br>

如上4+1视图通过将设计关注点划分到四个相互衔接的维度：逻辑视图，实现视图，部署视图，运行视图。这四个设计视图围绕着核心的用例场景视图，各自聚焦在一个设计切面，然后进行设计映射和衔接。

4+1视图除了给出了一个很好的设计思考维度的“guideline”，更重要的价值是：**它为顶层设计引入了抽象层次**。

我们前面提到软件支持灵活部署或者可裁剪，这些都是软件架构中的不同变化方向。而在设计中解决变化的问题，让架构能够面向某个变化方向进行扩展，最重要的手段就是抽象。

4+1视图要求设计从逻辑视图开始，逻辑设计应该聚焦于软件核心的业务逻辑概念和关系，和具体的代码分仓、目录结构、部署方式、调度方式暂时无关。

比如对“支持灵活部署”的设计场景，在逻辑视图设计中应该聚焦业务逻辑中最本质的实体和关系，不要过早的被某种部署方式绑定。而在部署视图设计的时候再进一步考虑系统中需要支持哪些部署方式，于是设计针对的部署机制和适配逻辑，以支持将逻辑视图中的设计元素往不同部署节点上编排和映射。这样逻辑视图的设计结果是可以在不同的部署场景下复用的。

目前我们看到4+1视图在团队中的使用，更多的是在将现有的代码设计和实现往上搬移，期望以此能做到设计的可追溯。而普遍还没有把它作为一个设计工具，发挥好它对设计的抽象和分层的指导价值。

不过也不用对4+1视图期待过多，毕竟它只是一个顶层设计维度的guideline指导，更进一步的精细化设计仍然得依靠其它方法和能力。

## 数据结构与算法设计

嵌入式软件对性能的要求是苛刻的，而设计好数据结构与算法则是关乎性能的核心要素，这点应该是每个软件工程师的基本功。

回到具体设计层面，优秀的软件工程师会将数据结构和算法封装起来，用能表达业务语义的名称和组织方式进行管理，以优先突出整体的业务逻辑和协作过程。

[“tcmalloc design”](https://github.com/google/tcmalloc/blob/master/docs/design.md)是Google的一个内存管理库`tcmalloc`的设计文档。对这样一个底层的内存管理库来说性能是首位的，因此设计文档里面核心在描述关键数据结构和算法的设计。

但是我们看其设计文档中的各种命名和代码中的实现，会发现它从设计到实现都会优先把数据结构和算法细节隐藏起来，保证了设计的易理解和具体实现的可替换性。

然而回观嵌入式系统软件的大部分实现，各种底层数据结构的选型直接暴露给使用方，即使C++的代码中也是vector、map直接作为函数的参数和返回值四处传递。

而我们知道：数据的逻辑语义一般是稳定的，而数据的结构特征却相对容易的变化，因此我们经常需要根据数据的结构特征变化为其选择更高效的数据结构实现。

如果数据结构和算法直接暴露，未来性能调优和演进的成本则会很大。做好对数据结构和算法的封装和清晰表意的设计，是对一个进阶的软件工程师的能力要求。对此感兴趣的同学，可以进一步阅读这篇和此话题有关的好文：[《容器与封装》](https://www.jianshu.com/p/6860593dedc1)。

我们在一项与华为海思的面向神经网络的内存管理算法的合作中，首要目标是算法设计，但由于一开始就注重对算法和数据结构的封装，最终做到了在设计和实现中快速迭代了近十种不同的内存管理机制，最后根据测试结果在里面选择了一种最优的实现。这体现了对数据结构和算法面向业务逻辑进行封装所带来的设计价值。

## 数据建模设计

嵌入式系统软件中普遍存在大量的静态配置数据。这些数据大多用于描述硬件的规格、驱动的参数和特性的配置等等。

因为静态配置数据一般要在代码的编译期中使用，在数据规模不大的情况下经常以表驱动设计为主，直接存在于软件代码中。

随着软件系统的规模变大，支持的硬件款型和功能愈来愈多和复杂，静态数据的规模也会急剧膨胀。一些大型系统中的静态配置数据的代码量动辄百万行以上，这时对数据的建模设计就会变得非常重要。

对数据进行建模的目的是要消除数据间的重复，维护好数据的一致性，管理好数据间的依赖，提升数据的访问性能，降低数据占用的存储资源，提高数据的可理解性等等。

如果数据规模大，那么首要是将数据与代码分离。毕竟代码为了优先表达逻辑而存在，并没有为数据的表达、编辑、维护和可视化提供足够的支撑。其次是选择合适的数据Schema和存储方式，为数据建立合适的视图，并对数据的管理和集成开发相应的工具链。

对于复杂嵌入式系统，这里的难点在于，首先大部分嵌入式工程师的能力集中在业务软件的逻辑设计上，对于如何进行数据建模和管理缺乏能力建设和经验，多数人对各种数据建模的范式和方法不熟悉。

其次，嵌入式系统软件中的静态数据大概率要参与到构建、部署和启动过程中，分离出去的数据如何选择合适的技术栈进行管理，做到既能方便数据的开发维护，又能和代码工程良好协作，同时还能保证性能要求，是需要一定的经验的，设计不好反而会增加工程复杂度。

我们在一些合作项目中，采用面向维度的数据建模，然后通过设计某种内部DSL（domain-specific language）来进行数据的表达和管理，同时开发对应的工具链进行数据校验、代码生成、编译二进制，以及集成到软件的构建、部署和加载过程中，从结果看都取得了不错得效果。

这种方法在实践中需要设计开发人员同时具备一定的工程工具的设计和开发能力。而实际情况中，大多数团队中的工程工具开发人员是和业务软件开发团队分离的，这样势必造成这些与业务软件架构紧密相关的工程工具的协同设计和开发的效率比较低。

业界顶级的公司大多通过鼓励软件工程师能力的多元性来解决这一问题，这样对于需要多种设计能力和工程工具协同设计开发的事情，则可以更快地达成并落地。

而复杂嵌入式系统的工程和工具的开发是有一定门槛的，因此如何平衡好通用工程工具和针对业务软件特点的工程工具的开发人员配比和流动，也是一项需要差异对待和持续优化的事情。

## 面向对象分析与设计

数据建模中常用的实体关系(ER)建模，虽然提出了要在设计中对业务概念和关系进行抽象，但是并不针对软件逻辑该如何有效的组织和交互。

嵌入式系统软件中，常见的模式是在一个模块中的`.C`文件中定义全局变量或者全局数据结构，然后实现围绕着这些全局数据的逻辑过程，最后在`.h`文件中把对应的类型定义和接口声明发布给别人使用；

在这种设计和实现方式中，对逻辑流程的跟踪基本上是线性的，顺着代码处理过程一句一句事无巨细的读下去，对于不复杂的系统就可以跟踪完所有逻辑处理过程。

遗憾的是对于稍微复杂的系统，这种方式会导致代码中处处充满和全局数据的读写和状态的交互。一旦一个函数访问了全局数据，那么就不得不去跟踪这个全局数据的其它所有修改函数，才能搞明白当前这个函数的完整逻辑上下文。想要复用这个函数就得把和它关联的全局数据以及其它关联出来的函数全部带出，这样的软件想要理解或者复用其中的一部分是困难的。

面向对象通过将数据和行为按照高内聚低耦合的原则封装在一起，形成更小的逻辑闭包（class），有效的解决了上述的问题。虽然很多人刚开始使用面向对象语言首先复用的是类似STL这类的容器算法库，但是面向对象的思考维度本质上比单纯的面向数据结构与算法的思考维度要高，它是面向逻辑概念思考的。

因此，面向对象里面的的设计概念也就更复杂，在设计上会把类分为边界类、控制类、实体类和值对象，把关系分为关联、聚合、组合、泛化和依赖，它要考虑对象的生命周期和所有权设计。

> 如果在使用面向对象得到的设计结果中，大部分的类都是单例类，主要业务逻辑类都是上帝类，经常直接把容器类作为函数参数和返回值，那么基本可以说明是没有掌握面向对象了。

一个软件团队要提升软件设计水平，就必须在平均能力上迈过面向对象设计和实现的这个门槛。这和使用的编程语言无关，和是否在用UML无关。可以参考一下Linux内核中的设备驱动架构，妥妥的C语言的面向对象设计和实现。

对于复杂嵌入式系统软件，即使在局部设计中使用面向对象的设计思想，也能产生比较明显的收益。

例如通讯设备软件中广泛使用的MO（Managed Object）建模，抽象了设备中的可管理对象和其属性、关系和校验约束，并将其按照一定的标准进行模型化描述。最终对设备进行操作维护管理的接口就可以标准化，部分的代码也可以通过模型自动生成。事实证明了基于MO模型的代码的可理解性、可复用性和可扩展性明显好于其它代码。

## 模型驱动设计

面向对象最风靡的时候带起了第一波的软件建模和模型驱动架构的流行，最终产生了 OMG(Object Management Group) 定义的各种标准和规范，和 MBSE(Model-Based Systems Engineering) 这样系统级的模型驱动的工程方法。

业界已经通过实践证明，完整的模型驱动架构的方法论只在一部分的软件领域得到了实施，对于变化频率比较高的软件来说流程繁重难以持续。

我们以汽车行业为例，一直以来，车的软件设计开发采用的Autosar的CP(Classic Platform)标准，遵循的是模型驱动的设计方式。

首先车机软件顶层设计的核心是围绕着CAN/LIN的通讯矩阵设计，这部分关注的是高安全性，需要全局的建模设计和代码生成，以保证通讯的安全性要求和可自动化验证。

其次车内的部件，在传统上是 OEM(Original Equipment Manufacturer) 向 Tier One 和 Tier Two 采购后组装集成，因此需要行业遵循标准的模型接口，以便 OEM 厂商可以通过建模自动生成通讯中间件把不同部件厂家的软件联通起来。

最后每个部件上运行的逻辑代码(也就是Autosar CP中说的SW)本质是单片机软件，一般规模不大，而且大多处理的是模拟信号和数据，需要通过Simulink进行仿真建模和代码生成。

可见，模型驱动架构之所以在车机软件中有效，和车的生产研发方式、软件特点、以及行业标准紧密相关。

然而到了智能车时代，由于计算力开始集中，软件的规模迅速变大，变更频率也变快，特别是智能辅助驾驶系统和智能座舱系统的软件，用传统车机软件的开发方式效率已然跟不上了。

虽然Autosar适时地推出了AP(Adaptive Platform)标准，为这类软件提供了基于模型驱动的自适应设计和开发方式，但现实是AP标准还是太复杂和繁琐，为了定义一个进程服务需要从`Machine`开始到`Service Interface`逐层建模映射，学习门槛高，开发效率低，目前推广的并不理想。

## 敏捷软件设计

敏捷软件设计从2000年开始伴随着互联网软件的兴起而流行起来。

互联网软件的特点是变化频率非常快，对需求变化不好提前预测，需要根据用户的流量进行快速迭代和设计调整，感兴趣的同学可以看看《增长黑客》一书。

由于敏捷软件开发的目标就是为了快速响应变化，因此任何阻碍沟通和反馈周期的繁重设计流程，都被认为是需要被改进的。

在敏捷软件设计开发中被普遍接受的一种观点是 “软件源代码是唯一真正的设计”。一些偏重技术实践的敏捷软件开发方法，如极限编程（XP），极大的推动了这方面的实践：人们优先将精力投入到代码上，持续保持代码的clean和灵活性，通过重构代码来演进设计，并通过自动化测试和软件流水线来确保设计演进的正确性和安全性。

敏捷运动后来逐步的渗透到嵌入式软件领域，带来的好处是推进了现代软件工程在嵌入式系统开发中的应用，比如Clean Code、开发者测试、重构，持续集成等等。

对于设计，由于敏捷方法给出的建议是软件开发中只有一个权威的设计，那就是代码。持续保持代码自身是自注释、易理解的，团队成员以清晰自注释的代码作为沟通的核心，这导致了敏捷很快被讹传成了一种完全不要设计和文档的开发方式！

其实**敏捷设计极大的推进了面向变化的设计方法**。从早期的“设计模式”，再到 Robert C. Martin 在《敏捷软件开发原则模式与实践》中总结的`SOLID`设计原则，再到后来 Kent Beck 总结的“简单设计原则”，到《程序员修炼之道》提出“设计的正交性”，再到 Robert C. Martin 的 《Clean Architecture》，无不有效地推进了面向变化的软件设计方法论。

然而嵌入式领域的敏捷转型，则更多的把关注点放在了敏捷的管理实践和工程实践上，对这些设计方法论并没有有效普及到一线的设计和开发工程师群体。

例如，多数的情况下，一个嵌入式系统软件的开发人员往往不能快速的说出他所开发维护的软件面临的主要变化方向，以及针对这些变化方向所做的软件设计和框架机制。因此我们常见的情况是，来了一个变化，代码动辄几百处的`if-else`的霰弹式修改，不仅容易遗漏，而且测试成本很高。或者干脆拷贝出来一份定向修改，造成代码量急剧膨胀，后期bug同步和维护成本很高。

假如一名嵌入式系统工程师所能举出的变化方向是“芯片变化“、”单板换代”、“协议升级”等这种粒度粗细，那么他应对变化的设计能力也只能到这个级别。

如果能稍微进一步将变化继续拆分，我们就知道驱动软件的常见变化方向是“寄存器地址”、“总线依赖”、“静态参数”等，单板软件的变化方向是“同物理器件的不同驱动实现”、“器件拓扑关系”、“器件规格“等；中间件类软件的变化方向是”资源约束“、”调度策略“、”部署方式“等；资源管理软件的变化方向是“资源规格”、“资源约束”和“管理算法”等；控制类软件的变化方向是“业务流程”、“消息格式”、“事务机制”等等。

这些变化方向还可以继续进行拆分并进行变化的溯因，最终得到一棵变化关联树，随后需要针对性的按照“正交设计”将变化进行分离和抽象，对其规划依赖方向，选择合适的组合方式，最终得到一个可以应对变化的正交设计结果。

## 领域驱动设计

虽然敏捷方法对面向变化的设计方法有所建树，但是针对复杂嵌入式系统软件，敏捷提倡以轻量级设计和代码驱动的方式往往容易显得缺乏骨架和力不从心。

2003年 Eric Evans 写了《领域驱动设计-软件核心复杂性应对之道》一书，提出了“领域驱动设计”方法（简称DDD：Domain Driven Design）。

DDD 指出以“领域建模”为核心的设计方法对于复杂软件领域是非常有价值的。但是它摒弃了传统的模型驱动设计中的多阶段多模型的设计方式，而是建议进行轻量级的建模；提倡在软件的分析、设计和编码阶段应该围绕一个统一的设计模型，这个模型被称之为“领域模型”。

领域模型应该由业务专家和软件团队共同设计建立，它沉淀了业务软件的核心价值，承载了软件在其完整生命周期中的概念一致性，可以作为所有参与者的通用语言。

此外，DDD要求代码实现应该是与领域模型持续保持高度一致，这降低了软件开发中的沟通和修改成本。

在方法论上，Eric Evans提出了DDD要遵循“战略设计”和“战术设计”两个阶段，并标准化了战术设计阶段的“建模元素”。

然而，DDD的设计流程是不完整的，在实践中存在很多漏洞。虽然社区在不断地完善该方法，但是在实际使用中大多数公司都是将其作为一个重要的参考方法论来用。

如果你关注Google、Facebook、微软等企业的设计方法，不会发现他们在公开场合宣称自己在使用领域驱动设计方法。

对于复杂嵌入式系统软件，DDD的战略设计环节的尴尬，在于它给出的战略设计结果通常难以指导顶层架构设计（前面说了复杂嵌入式系统软件的架构更多的是被产品标准、行业经验、硬件架构和性能约束决定的）；而DDD的战术设计结果也指导不了完整的软件细节设计（至少到不了数据结构和算法这个影响模块核心性能的设计环节）。

对于复杂嵌入式系统软件，DDD所提倡的领域建模设计的最佳位置，是作为模块级别的逻辑视图的一种设计方法。至于“领域模型”如何解决嵌入式系统软件中常见的变化问题（如多硬件、灵活部署、可裁剪）和性能问题，需要软件设计人员综合发挥我们前面提到的其它设计能力去弥补。

嵌入式领域使用DDD方法的另一个问题是“布道师短板”问题。

在DDD方法流行的IT软件领域，建模的出发点主要基于业务流程，采用以业务事件为主线的概念和关系推导过程。这样的领域建模方法论迁移到嵌入式领域最多只适用于以业务交互控制为核心的模块，对其它类型的软件模块都是不完备的。

这是因为在IT类软件的视角中，其低层的计算、存储和网络资源基本可以认为是标准的。而大部分嵌入式系统软件对上下都是开放的，向上需要支撑各种业务场景和流程的达成，向下需要管理和控制多种专有硬件器件和业务逻辑资源，往往这些硬件的结构和资源管理的方式也在频频变化。

因此嵌入式软件的领域建模设计需要充分了解模块的业务功能、了解涉及到的硬件组成、逻辑资源、协议、性能约束，主要的变化方向等，否则模型中的概念和关系就容易缺失，导致最终模型不能有效解决实际问题。

在和团队的合作过程中，我们提出一种“自顶向下分析”和“自下向上设计”相结合的领域建模方法，同时从“业务场景”与“硬件或逻辑资源状态”两条线出发进行模型概念和关系的推导，并完成从领域模型到调度模型、内存模型和通信模型的映射，同时在设计的过程中一遍遍的用最终的多维设计目标来验证和调整当下的模型设计，最终得到一个可以解决和平衡好各方面问题、满足性能约束和具备可扩展性的领域模型设计。

对于嵌入式软件来说，采用DDD方法还有一个难点，就是如何对领域模型进行代码实现和测试？这关系到DDD所强调的代码与模型的一致性，以及测试与模型的一致性问题。这个话题很重要，我们放到未来某期专门针对代码实现的文章中再详述。

## 演进式设计

复杂嵌入式系统中包含了各种不同特点的软件部件，在它们的长生命周期过程中，每部分的代码规模和面对的主要问题也一直发生着变化，因此很难用一种标准的设计方法来解决所有问题。

例如某一常见的嵌入式软件模块的设计演进过程可能是这样的：

- 早期规模不大的时候，主要的设计是如何定义好接口、依赖、数据结构和算法，高性能的完成业务逻辑；
- 如果和软件有关的静态数据越来越多，可能需要将数据分离并且针对数据进行数据建模，并设计与代码的集成方式；
- 如果模块的逻辑越来越复杂，可以采用面向对象设计将逻辑和数据结构进行封装，设计对象间关系和对象的生命周期管理；
- 如果对象数量变多并且关系复杂化，可以借助领域驱动设计获得概念一致和易于理解的领域模型来指导设计和代码的演进；
- 如果模块受到不同变化方向的冲击越来越频繁，可以为软件设计引入多维视图模型，通过抽象和正交设计来分离变化、提高软件的可扩展性；

那么可否对于所有软件模块，一上来就用最全面和最复杂的设计方法呢？

下图是Martin Flower在《Patterns of Enterprise Application Architecture》一书中，给出的领域驱动设计与其它设计方法在项目不同阶段的成本对比。

<div align="center"><img src="images/OIP-C.jpeg" width="60%"></div>

可以看到过早的使用领域驱动设计方法是高成本的！复杂系统中不同软件部分的变化频率和面对的核心挑战的差异是比较大的，一刀切的方式是不经济的。

更值得推荐的方式是采用**演进式设计**：就是随着软件本身的规模、复杂度以及面临的主要挑战和变化，适应性地选择合适的设计方法和工程工具来帮助软件以低成本的方式进行持续的设计演进。

Martin Flower在[《Is Design Dead?》](https://www.martinfowler.com/articles/designDead.html) 一文中指出：不同于传统的计划式设计，演进式设计的目标是通过一系列的技术和工程实践（这主要包括 Clean Code、重构、开发者测试、持续集成，以及简单设计 和 正交设计等设计宗旨），让软件持续保持在可以低成本调整设计的状态，从而可以随时根据需要对软件进行设计演进。

和敏捷设计一样的是，演进式设计也认为设计是需要逐步迭代的，但是它从名字上把设计放到了突出的位置上。所以不要将“演进式设计”作为不做前期设计的借口，相反演进式设计强调的是**需要针对能够确定的信息做好预先设计**，而对未知的难以预测的部分我们有能力将设计延迟到变化真正发生的时候，再通过重构等技术手段让设计和实现进行演进。

演进式设计对复杂软件系统的交付更为重要，这是因为对于复杂系统，要在前期把所有的需求和约束都考虑完整，基本上很难做到；就算是做到了，很大概率上一些需求和约束也会在随后的开发过程中发生变化。

另外我们知道软件交付是由诸多环节组成的，即使为前期设计预留足够长的时间，交付的结果质量也未必会等比例提升。而如果能够更快的进行端到端验证，然后根据反馈结果对瓶颈环节进行改进，这种能力是非常具有价值的。

我参加过不少所谓“下一代软件架构”的设计研讨封闭会议，其中冗长的会议和低效的沟通消耗了绝大多数参会者的热情，讨论中的诸多不确定的和低概率的假设又让人疲于应付，每个人心里都知道肯定会有很多真正的问题会在实现和测试环节冒出来，但当下却没人能快速地通过原型代码得出一些评估和验证结果以提供给设计做参考和修正。

在这种设计会议上，我经常建议大家通过实例化需求和领域模型来表达需求和设计。

`需求实例化`和`领域建模`的过程逼迫了设计者首先刨除模糊不清的信息，然后通过严谨的、自解释的、可以在每个人的头脑中以严格逻辑进行复现和验证的软件模型，来呈现场景和设计结果。

因此，演进式设计的最佳过程承载是领域模型，如果能配合着核心框架或者原型代码进行补充和验证，那么就更赞了！而对于不确定的需求和约束，我们可以选择对其`延迟决策`，等到信息明确的时候再来演进模型和实现。

而在《领域驱动设计》中，Eric Evans 通过下图来说明，及时和频繁的代码重构正是演进领域模型的重要手段。

<div align="center"><img src="images/DDD.png" width="60%"></div>

因此，对于复杂的长生命周期软件来说，重构肯定不是一种运动，而是需要内建在软件的生命周期过程中，通过重构来不断的演进设计和实现，甚至借助重构过程来引进更新的基础设施和工程工具，提高整个组织进行演进式设计的能力。

我们今天提倡建设重构能力，如果目标仅仅是消除告警和Clean Code，没有通过重构锻炼出需要的设计能力和锻造出更高效的工程能力，那么就有些可惜了。

## 结语

时至今日，虽然 AI 如火如荼，但是软件设计依然没有“银弹”！对于大规模嵌入式系统软件，由于其内在的复杂性，这点表现的更加明显。

一个组织在软件设计能力上的领先，往往就是建立在对**设计能力提升**所带来的**长期复利效应**的积累上。

在这方面，慢就是快！在能力建设的过程中，过早过急的想要度量想要成绩往往适得其反。
