2025年Q4，为了完成一份重量级别的技术报告，所以开发了一个用于专业写作的Agent：[Dogent](https://github.com/MagicBowen/dogent)；

在这个过程中，有一些有意思的事情和一些心得和实践经验，值得记录。

第一个有意思的事情是：这个工具开发的过程完全一个“吃自己狗粮”、自我闭环的过程：一遍用这个Agent辅助进行报告写作（调研、优化、审核...），一遍通过写作测试这个Agent，驱动更多的功能开发和优化；

同时通过开发这个工具，本身对 Agent 技术栈和实现有了更多的实践和思考：1）Agent 类软件的技术栈特点，不同 agent sdk 的区别；静态编排类和动态的agent SDK的区别；什么类型的软件应该通过Agent“扮演”完成，什么类型的需要生成确定性代码完成... 2）不同模型的区别（GLM4.7、DeepSeek 以及与闭源头部模型 GPT5.2...）;  3) Agent 上下文管理技巧、Agent 交互设计技巧、Agent的临时记忆管理；4）Agent如何能持续自我改进（lession能力）；4）Prompt的最佳实践（提供context而非control）；

同时这个工具又是通过 Vibe Coding 的方式完成的（使用 Codex CLI，模型师 codex 5.2 high），在这个过程中对于 Vibe Code做了一些有意思的实验：
- 完全没有任何 Spec，裸的和 Codex 交互，驱动完成 Dogent 的开发，发现基本代码规模到达 2000+，就写不下去了（LLM各种失控，反复prompt驱动成本很大，自己的思维也乱掉）
- 组织了一套 Spec 驱动的方式： Requirement -> Design -> Sprint Plan -> Implement -> Auto Tests -> UAT Test -> Issues Fix -> Release，采用系列文件组织，基本上完全不用人工编码，驱动代码规模可以到 10000+，完成了 Dogent 的基本功能；这里面的 requirement 和 uat 是人做的（人决策做什么，以及从终点验收），另外 design之后的澄清需要人的修正和反馈；
- 复杂需求需要独立做 spike，spike结果保存为markdown，然后提供给 Codex 作为设计和实现参考；spike可以独立到另外一个 codex 中进行，和主 codex 隔离上下文；
- 当代码逻辑复杂后，容易出错，这时候软件会有各种 bug，对于dogent来说主要是各种监听事件、异步处理、和异常情况下的处理问题，这时候需要参与指导的设计是：可调可测。引入了 logging 的设计以及对关键事件和异常的记录，通过给 Codex 问题描述以及日志驱动Codex更好的解决问题（Codex 也会自己使用 logging 进行代码打点跟踪问题）
- 当代码复杂度更高之后，架构需要做一些解耦和重构。原因：Codex自己的代码容易形成单体，最核心的逻辑塞到一个文件，导致出现超过5000+的大文件（每次读到这个文件，上下文就消耗很快），因此人需要参与进来读代码，并给 Agent 提出一定的重构要求和指导，重构过程完全由 agent 完成；
- 这里面的收获是：在 Agent 辅助编码时代，匹配的 spec 是必须的。其次，软件本身的可观测性是重要的（帮助 Agent 进行问题定位）。最后面向上下文的进行的架构解耦是必须的（让每个增量开发的上下文可控，让agent可以操控更复杂的软件规模）
- Agent辅助软件开发时代好的软件架构
    - 1）可观测性好；
    - 2）没有霰弹式修改的问题，单一特性可以在确定有限上下文下完成（把复杂系统变成繁杂型系统）；
    - 3）软件的依赖关系显式化（静态依赖和动态依赖？静态依赖构建（DSL），动态依赖通过测试和 DBG 可以跟踪（补充活动图）？；
    - 4）从业务入口到实现框架的直接映射；
- Agent辅助软件设计的关键：做好过程管理和上下文管理，面向上下文的拆分（最终让每个story都能落在有限上下文内完成）


# 从 Vibe Coding 到 Vibe Writing

## 为什么要专门下一个 Vibe Writing 的 Agent，直接使用 Claude Code 不好吗？


## AI 时代软件的技术选型 “光谱”


## 模型的影响大吗？



## 开发过程需要如何管理？


## 未来的设计会如何做？


## prompt 有哪些最佳实践？


## 上下文管理有哪些最佳实践？



claude code 比 n8n 等流编排的好处？

让 code review agent 等都好做了...

claude code 不如 agent sdk的不足：
- system prompt 不能定制
- Agent loop 不能定制：例如 打断，打断的处理...
- 交互方式不能定制：如 写作体验，问题追问，快捷键...
- 与其它能力的内置集成：image，pdf
- 国内限制：web search...
- 国内模型调优：deepseek，glm...

---
模型对比：
GLM 4.7：虽然快，但是指令遵从差
DeepSeek：慢，上下文短，指令遵从尚可

---

每次都要拷贝
prompt 要重写，没有积累
模板不能共享
在线搜索，图片理解，PDF（模板配置）和docx阅读与生成

claude code 的写作风格（system prompt）

更易用编辑和输入的 CLI 交互体验

调试 deepseek 和 glm

## Dogent purpose

## vibe writing

## Procedure

1 ~ 2000:
2000 ~ 10000: 
- process

> 10000: design

当规模变大，很多不一致性就会出现，人需要决策。而决策是复杂的，需要考虑未来的可能，LLM可以提示，合作，但是LLM对未来的真实演变没有人耦敏感度和话语权的。所以还是得人来决策。这时人的决策质量就很重要，当决策在未来证明是失败的，影响范围也很重要；

当规模变大，故障也越来越难解决，可观测性设计很重要（设计了日志和异常处理应对，让模型分析）

将软件解耦为 《 10000 行的小模块，独立 vibe 完成! 减少 IDE，完全 vibe

---

提供知识，而非指令

